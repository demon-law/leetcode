# 228. 汇总区间

---

题目来源：力扣（LeetCode）[https://leetcode-cn.com/problems/summary-ranges/](https://leetcode-cn.com/problems/summary-ranges/)

## 题目

---

给定一个无重复元素的有序整数数组 `nums` 。

返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

 

**示例 1：**

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**示例 2：**

```
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

**示例 3：**

```
输入：nums = []
输出：[]
```

**示例 4：**

```
输入：nums = [-1]
输出：["-1"]
```

**示例 5：**

```
输入：nums = [0]
输出：["0"]
```

 

**提示：**

- `0 <= nums.length <= 20`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中的所有值都 **互不相同**
- `nums` 按升序排列

## 解题思路

---

### 思路：双指针

先审题，题目给定的数组 $nums$ 的元素是无重复且有序（升序）的整数。

题目要求：

- 返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。

其中，列表中输出的区间范围，如 $[a, b]$ 有如下格式：

- 如果 **a != b**，输出 **"a -> b"​**；
- 如果 **a == b**，输出 **"a"**。

因为数组中的元素均为整数，结合示例 1​、2 来看，元素间隔为 1 才能够被划入同个区间中。以示例 1 为例：

```bash
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
```

我们看最终的输出结果是三个区间范围：

- "0->2"，这个区间范围包含了元素 0，1，2；
- "4->5"，包含了元素 4，5；
- "7"，则包含单独的元素 7。

在这里 **"0->2"** 和 **"4->5"**，两者无法划分在同一个区间，是因为前者区间的右边界，与后者区间的左边界间隔大于 1。若数组中还存在元素 3，那么这两者就可以划分在同一个区间中。那么也就说，找到前后元素值间隔大于 1 的部分，就能够将划分出不同的区间范围。

现在数组有序，这里我们可以用双指针的方法，具体思路如下：

- 定义双指针 $left$、$right$，初始化均指向数组头部；
- 开始遍历数组，移动 $right$ 指针，限定边界查找前后元素值间隔大于 1 的部分：
  - 即是判断 $nums[right] + 1$ 跟 $nums[right+1]$ 是否相等。若相等，继续移动 $right$ 指针；若不相等，或 $right$ 指针到达边界。开始划分区间，按照规定格式添加到结果列表中。
- 注意维护更新 $right$ 指针和 $left$ 指针。

具体的代码实现如下。

```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        n = len(nums)
        # 初始化双指针均指向数组头部
        left = 0
        right = 0

        ans = []
        # 开始遍历
        while right < n:
            # 数组有序
            # 先限定边界，查找间隔大于 1 的部分
            while right < n - 1 and nums[right] + 1 == nums[right+1]:
                right += 1
            # 找到间隔之后，将前面连续部分按照规定格式添加到结果列表中
            tmp = [str(nums[left])]
            if nums[left] != nums[right]:
                tmp.append('->')
                tmp.append(str(nums[right]))
            ans.append(''.join(tmp))
            # 维护更新 right 和 left
            right += 1
            left = right
            
        return ans
```

## 欢迎关注

---

公众号 【[书所集录](https://i.loli.net/2020/07/09/sNEGeV8g6fmW5Ub.jpg)】

---

**如有错误，烦请指出，欢迎指点交流。若觉得 写得还可以，麻烦点个赞👍，谢谢**